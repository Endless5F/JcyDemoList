## 一、Java虚拟机结构
1. 数据类型：原始类型(原生类型或者基础类型)和引用类型
2. 原始类型与值：
    1. 整数类型
     1. byte类型(取值范围：-128~127,2^7)：值为8位有符号二进制补码整数，默认值为0
     2. short类型(取值范围：-32768~32767,2^15)：值为16位有符号二进制补码整数，默认值为0
     3. int类型(取值范围：-2147483648~2147483647,2^31)：值为32位有符号二进制补码整数，默认值为0
     4. long类型(取值范围：-2^63 ~ 2^63-1)：值为64位有符号二进制补码整数，默认值为0
     5. char类型(取值范围：0~65535,包括0和65535)：值为16位无符号整数表示，指向基本多文种平面的Unicode码点，以UTF-16编码，默认值为Unicode的null码点('\u0000')。
     注：基本多文种平面 BMP(Basic Multilingual Plane)，或称第零平面(Plane 0)，是Unicode中的一个编码区段。编码从U+0000至U+FFFF
    2. 浮点类型
        1. float类型：单精度浮点数集合或者(Java虚拟机若支持)单精度扩展指数集合中的元素，默认值为正数0
        2. double类型：双精度浮点数集合或者(Java虚拟机若支持)双精度扩展指数集合中的元素，默认值为正数0
    3. boolean类型：布尔值true或false，默认值false。虽然Java虚拟机定义了这种类型，但是对它只提供了有限的支持，在虚拟机中没有boolean值专有的字节码指令。boolean值在编译过后都使用Java虚拟机中的int类型代替，true为1、false为0.
    4. returnAddress类型：指向某个操作码(opcode)的指针，只存在于字节码层面，与编程语言无关。
3. 引用类型与值(默认值：null)
    1. 类类型：动态创建的类实例
    2. 数组类型：数组实例
        1. 组件类型：数组类型最外面那一维元素的类型，比如：int[][][]数组，其组件类型为int[][]
        2. 元素类型：从任意一个数组开始，若发现其组件类型也是一个数组类型，那就继续取这个小数组的组件类型，不断执行此操作，最终一定会出现组件类型不是数组的情况，此类型即为元素类型。
    3. 接口类型：实现了某接口的类实例或者数组实例
4. 运行时数据区
    1. pc寄存器：每个线程启动的时候，都会创建一个PC（Program Counter，程序计数器）寄存器。PC寄存器里保存有当前正在执行的JVM指令的地址。 每一个线程都有它自己的PC寄存器，也是该线程启动时创建的。保存下一条将要执行的指令地址的寄存器是 ：PC寄存器。PC寄存器的内容总是指向下一条将被执行指令的地址，这里的地址可以是一个本地指针，也可以是在方法区中相对应于该方法起始指令的偏移量。此区域内存空间很小，生命周期跟线程相同，可以为null，并且不会发生任何内存异常。
    2. Java虚拟机栈：虚拟机栈跟程序计数器一样，也是线程私有的，其生命周期跟所属线程相同。虚拟机栈的内容描述的是java方法执行时的内存模型。java方法的每次调用和执行完成返回都会对应一个叫做栈帧的数据结构在虚拟机栈中的入栈和出站操作。栈帧存储的是java方法执行时的局部变量表，操作数、动态链接和方法出口等信息。

            1. 每个方法（Method）执行时，都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口信息等
            2. 栈中所存储的变量和引用都是局部的（即：定义在方法体中的变量或者引用），局部变量和引用都在栈中（包括final的局部变量）
            3. 八种基本数据类型（byte、short、int、long、float、double、char、boolean）的局部变量（定义在方法体中的基本数据类型的变量）在栈中存储的是它们对应的值
            4. 栈中还存储局部的对象的引用（定义在方法体中的引用类型的变量），对象的引用并不是对象本身，而是对象在堆中的地址，换句话说，局部的对象的引用所指对象在堆中的地址在存储在了栈中。当然，如果对象的引用没有指向具体的对象，对象的引用则是null
    3. Java堆：是可供各个线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。

            1. 由关键字new产生的所有对象都存储于Java堆（Java Heap）
            2. 实例变量（非static修饰的成员变量）和对象关联在一起，所以实例变量也在堆中
            3. Java数组也在堆中开辟内存空间
    4. 方法区：与Java堆一样，是各个线程共享的内存区域，它存储已被Java虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。

            对每个加载的类（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：
                1. 这个类的完整有效名称（全名=包名.类名）
                2. 这个类直接父类的完整有效名称( java.lang.Object除外，其他类若没有声明父类，默认父类是Object)
                3. 这个类的修饰符(public、abstract、final的某个子集)
                4. 类的常量池(constant pool)：jvm为每个已加载的类型都维护一个常量池。常量池就是这个类型用到的常量的一个有序集合
                        1. 实际的常量(string, integer, 和floating point常量)和对类，域和方法的符号引用。
                        2. 池中的数据项和数组项一样，是通过索引访问的。因为常量池存储了一个类所使用到的所有类型，域和方法的符号引用，所以它在java程序的动态链接中起了核心的作用。
                5. 域(Field)信息(即：成员信息)：jvm必须在方法区中保存类的所有域的相关信息以及域的声明顺序
                   域的相关信息包括：
                        1. 域名
                        2. 域类型
                        3. 域修饰符(public, private, protected,static,final volatile, transient的某个子集)
                6. 方法(Method)信息：jvm必须保存所有方法的以下信息，同样域信息一样包括声明顺序
                        1. 方法名
                        2. 方法的返回类型(或 void)
                        3. 方法参数的数量和类型(有序的)
                        4. 方法的修饰符(public, private, protected, static, final, synchronized, native, abstract的一个子集)除了abstract和native方法外，其他方法还有保存方法的字节码(bytecodes)操作数栈和方法栈帧的局部变量区的大小
                        5. 异常表
                7. 除了常量外的所有静态(static)变量
            方法区（Method Area）存储的常量：static final修饰的成员变量都存储于 方法区（Method Area）中
            方法区（Method Area）存储的静态变量：
                1. 静态变量又称为类变量，类中被static修饰的成员变量都是静态变量（类变量）
                2. 静态变量之所以又称为类变量，是因为静态变量和类关联在一起，随着类的加载而存在于方法区（而不是堆中）
                3. 八种基本数据类型（byte、short、int、long、float、double、char、boolean）的静态变量会在方法区开辟空间，并将对应的值存储在方法方法区，对于引用类型的静态变量如果未用new关键字为引用类型的静态变量分配对象（如：static Object obj;）那么对象的引用obj会存储在方法区中，并为其指定默认值null;若，对于引用类型的静态变量如果用new关键字为引用类型的静态变量分配对象（如：static Person person = new Person();）,那么对象的引用person 会存储在方法区中，并且该对象在堆中的地址也会存储在方法区中（注意此时静态变量只存储了对象的堆地址，而对象本身仍在堆内存中）
            方法区（Method Area）存储的方法（Method）：
                1. 程序运行时会加载类编译生成的字节码，这个过程中静态变量（类变量）和静态方法及普通方法对应的字节码加载到方法区。
                2. 方法区中没有实例变量，这是因为，类加载先于对应类对象的产生，而实例变量是和对象关联在一起的，没有对象就不存在实例变量，类加载时没有对象，所以方法区中没有实例变量
                3. 静态变量（类变量）和静态方法及普通方法在方法区（Method Area）存储方式是有区别的
    5. 运行时常量池：jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。

            1. 运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
            2. 运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。
            常量池的好处：
                常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。
                    （1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。
                    （2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等
    6. 本地方法栈：本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。
    7. Java虚拟机运行时数据区内存详情，具体参考：com.android.javalib.jvm.JvmMemoryClass
5. 栈帧





















