1. Java的char是两个字节，如何存utf-8字符？
    ```
    面试官视角：这道题想考察什么？
            1. 是否熟悉Java char和字符串(初级)
            2. 是否了解字符的映射和存储细节(中级)
            3. 是否能触类旁通，横向对比其它语言(高级)
    题目结论：
        初级：Java char不存utf-8的字节，而是utf-16，占两个字节；utf-8是1-6个字节存储；Unicode字符集（码点，人类认知层面的字符映射成整数，字符集不是编码）
        中级：Java char中存储的是utf-16编码。Unicode通用字符集占两个字节，'中'，占一个char两个字节，byte[] bytes = '中'.getBytes("utf-16")--> 结果为：fe ff 4e 2d（fe ff为字节序）
        高级：
            1. 令人迷惑的字符串长度：字符串长度 != 字符数（比如：表情emoji，一个字符数，占两个长度）
            2. 触类旁通：
                1). Java9中对拉丁(Latin)字符优化：例如若字符串中是ascii码字符，只需要7个byte一个字节表示存储，而使用utf-16存储明显是有压力的。Java9若发现整个字符串中只有ascii码字符，则会使用byte来存，不使用char存储，这样就会节省一半字符，此时字符串长度 也!= 字符数。
                2). Java(String emoji = "emoji表情"，长度为2) == Python(>=3.3，emoji = u"emoji表情"，长度为1)
    ```
2. Java String可以有多长？
    ```
    面试官视角：这道题想考察什么？
        1. 字符串有多长是指字符数还是字节数(初级)
        2. 字符串有几种存在形式(中级)
        3. 字符串的不同形式受到何种限制(高级)
    题目结论：
        初级：分为两种形式写在代码中的字面量和文件中的字符串，即存在于栈内存中和堆内存中
        中级：
            栈内存中：字面量中，受限于Java代码编译完成的字节码文件CONSTANT_Utf8_info结构中的u2 length。u2代表两个字节，即长度最大为16位二进制表示，因此最大长度为65535。CONSTANT_Utf8_info运行时，会被加载到Java虚拟机方法区的常量池中，若常量池很小，字符串太大，会出现异常，常量池一般不会连65535都无法存储。
        高级：
            1. Java编译器的bug：实战过程中发现输入65535个Latin字符，编译无法通过，而65534则可以。Java不会和c语言中一样，在字符串中加一个'\0'。Java编译器(Javac)中判断字符串长度时使用的是 <65535 号，而非 <=65535，因此65535无法编译通过。kotlin中是没有问题的
            2. String中若为中文字符，比如String longString = "烫烫烫...烫烫烫"; 烫占3个字节，理论上最长为 65535/3 个。实战输入65535/3个烫，发现是可以编译通过的，原因：Java编译器对于中文字符这样，需要Utf8编码这种，没办法在编译时直接知道到底需要占用多少字节，只能先通过utf-8编码，然后再来查看占多少字节。此写法判断长度时使用 >65535 ，因此此处是正确的。
            3. 总结：Latin字符，受Javac限制，最多65534个；非Latin字符最终对应字节个数差距较大，最多字节数为65535个；若运行时方法区设置较小(比如：嵌入式设备)，也会受方法区大小限制。
            4. 堆内存中：new String(bytes); 受String内部value[] 数组，此数组受虚拟机指令 newarray [int]，因此数组理论上最大个数为 Integer.MAX_VALUE。有一些虚拟机可能保留一下头信息，因此实际上最大个数小于 Integer.MAX_VALUE。即堆中String理论上最长为Integer.MAX_VALUE，实际受虚拟机限制小于Integer.MAX_VALUE，并且若堆内存较小也受堆内存大小限制。
    ```
3. Java匿名内部类有哪些限制？
    ```
    面试官视角：这道题想考察什么？
        1. 考察匿名内部类的概念和用法(初级)
        2. 考察语言规范以及语言的横向对比等(中级)
        3. 作为考察内存泄漏的切入点(高级)
    题目结论：
        初级：没有人类认知意义上的名字；匿名内部类的实际名字：包名+外部类+$N，N是匿名内部类的顺序(即在外部类中所有匿名内部类从上到下排第几)
        中级：
            匿名内部类的继承结构：匿名内部类必然有其父类或者父接口，在初始化匿名内部类new InnerClass(){ ... }，InnerClass类实际上就是此匿名内部类的父类
            匿名内部类只能继承一个父类或者实现一个接口，不能同时即继承父类由实现接口；kotlin中是可以的
        高级：
            匿名内部类的构造方法：编译器生成，匿名内部类可能会有外部类的引用，可能会导致内存泄漏。
                匿名内部类实际参数列表：
                    1. 外部类实例(定义在非静态域内)
                    2. 父类的外部对象(父类非静态，即父类是定义在一个类中，外部对象是指父类的外部类实例)
                    3. 父类的构造方法参数(父类若由构造方法且参数列表不为空)
                    4. 外部捕获的变量(方法体内有引用外部的final变量)
            匿名内部类参数列表所知：
                1. 父类定义在是非静态作用域内(即父类是定义在一个类中)，会引用父类的外部类实例
                2. 如果定义在非静态作用域内(非静态方法内)，会引用外部类实例(非静态方法内所在类的实例)
                3. 只能捕获外部作用域的final变量
                4. Java8：创建时只有单一方法的接口可以用Lambda转换(SAM类型)，只能是接口且接口中只有一个方法
    ```
4. Java
    ```
    面试官视角：这道题想考察什么？
        1. (初级)
        2. (中级)
        3. (高级)
    题目结论：
        初级：
        中级：
        高级：
    ```
5. Java
    ```
    面试官视角：这道题想考察什么？
        1. (初级)
        2. (中级)
        3. (高级)
    题目结论：
        初级：
        中级：
        高级：
    ```
6. Java
    ```
    面试官视角：这道题想考察什么？
        1. (初级)
        2. (中级)
        3. (高级)
    题目结论：
        初级：
        中级：
        高级：
    ```
7. Java
    ```
    面试官视角：这道题想考察什么？
        1. (初级)
        2. (中级)
        3. (高级)
    题目结论：
        初级：
        中级：
        高级：
    ```
8. Java
    ```
    面试官视角：这道题想考察什么？
        1. (初级)
        2. (中级)
        3. (高级)
    题目结论：
        初级：
        中级：
        高级：
    ```
9. Java
    ```
    面试官视角：这道题想考察什么？
        1. (初级)
        2. (中级)
        3. (高级)
    题目结论：
        初级：
        中级：
        高级：
    ```
10. Java
    ```
    面试官视角：这道题想考察什么？
        1. (初级)
        2. (中级)
        3. (高级)
    题目结论：
        初级：
        中级：
        高级：
    ```
11. Java
    ```
    面试官视角：这道题想考察什么？
        1. (初级)
        2. (中级)
        3. (高级)
    题目结论：
        初级：
        中级：
        高级：
    ```