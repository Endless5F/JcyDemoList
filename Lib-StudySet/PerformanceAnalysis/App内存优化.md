## 一、内存优化介绍及工具选择
1. 内存优化介绍
    * 内存溢出：OOM、程序异常
    * 内存泄漏：可用内存减少、频繁GC
    * 内存抖动：锯齿状、GC导致的卡顿
2. 工具选择
    * Memory Profiler
        1. 实时图表展示应用内存使用情况
        2. 识别内存泄漏、抖动等
        3. 提供捕获堆转储、强制GC以及跟踪内存分配的能力
        4. 总结：方便直观、线下平时使用
    * Memory Analyzer（MAT）
        1. 强大的java heap分析工具、查找内存泄漏及内存占用
        2. 生成整体报告、分析问题等
        3. 线下深入使用
    * LeakCanary
        1. 自动内存泄漏检测
        2. 线下集成
## 二、Android内存管理机制
### java内存管理机制
1. java的内存分配：

        方法区(存放java的类信息，常量，静态变量 等，是所有线程共享的)
        虚拟机栈(局部变量表和操作数栈等,为java方法调用服务的，线程私有)
        本地方法栈(为native方法服务的，线程私有)
        堆(所有线程共享，真正的进行内存分配，GC主要作用的区域)
        程序计数器(存储当前线程到多少行)
2. java的内存回收算法：

        标记-清除算法总结：标记清除算法：标记处所有需要回收的对象，同一回收所有被标记的对象。效率不高，产生大量不连续的碎片（内存空洞）
        复制算法总结：复制算法：将内存划分为大小相等的两块，一块内存用完之后复制存活的对象到另一块，清理另一块内存。实现简单，运行高效，浪费一半内存，代价大
        标记-清理总结：标记整理算法：标记过程与标记清除算法一样，存活对象往一端进行移动，清理其余内存。避免标记清除导致的内存碎片，避免复制算法的控件浪费。
        分代收集算法：集合多种收集算法的优势，新生代对象存活率低（复制算法），老年代对象存活率高（标记整理）
### Android内存管理机制
1. 内存弹性分配。分配值和最大值受具体设备影响（如高端机和低端机的不同）
2. OOM场景：内存真正不足、可用内存不足（整个系统内存都不足）
3. Dalvik与Art区别：

    Dalvik仅固定一种回收算法（运行期没法改变）；Art回收算法可运行期选择，Art具备内存整理能力，减少内存空洞

    DVM中的应用每次运行时，字节码都需要通过即时编译器（JIT，just in time）转换为机器码，这会使得应用的运行效率降低。而在ART中，系统在安装应用时会进行一次预编译（AOT，ahead of time）,将字节码预先编译成机器码并存储在本地，这样应用每次运行时就不需要执行编译了，运行效率也大大提升。
4. Low Memory killer机制(针对所有进程，当内存不足时，此机制会针对所有进程进行内存回收)：进程分类(前台-可见进程-桌面进程-服务进程-后台进程-空进程)，根据优先级从低到高依次回收、回收收益(此机制需要考虑回收的大小)
## 三、内存分析实战
1. 内存抖动

        定义：内存频繁分配和回收导致内存不稳定
        表现:频繁GC、内存曲线呈现锯齿状
        危害：导致卡顿、OOM
        内存抖动导致OOM的原因：频繁创建对象，导致内存不足及碎片（不连续），不连续的内存片无法被分配，导致OOM
        内存抖动解决技巧：找循环或者频繁调用的地方
    分析方法：使用Memory Profiler（可以观察内存曲线），具体详见：PerformanceAnalysis/性能分析/Memory Profiler内存抖动分析.png
2. 内存泄露

        定义：内存中存在已经没有用的对象
        表现:内存抖动、可用内存逐渐减少
        危害：内存不足、频繁GC、OOM
    分析方法：使用MAT(Memory Analyzer)工具进行分析哪些对象存在泄漏，MAT分析文件的制作详见：PerformanceAnalysis/性能分析/MAT工具分析文件hprof的制作.png
    MAT的使用的参考文档：https://www.jianshu.com/p/c8e0f8748ac0 (MAT使用进阶)、https://www.cnblogs.com/larack/p/6071209.html (内存泄漏 之 MAT工具的使用)
## 四、ARTHook优雅检测不合理图片
1. Bitmap内存模型

        API10之前Bitmap自身在Dalvik Heap中，像素在Native
            优点：不占用java层的内存，不易出现OOM
            缺点：bitmap被回收，native像素没有被回收，回收时机不确定
        API10之后像素也放在Dalvik Heap中
            优点：bitmap回收native像素也被及时回收
            缺点：占用java层内存
        API26之后像素在Native
            优点：不占用java层的内存，不易出现OOM
            Google解决了不能及时回收的问题
        获取bitmap占用内存：
            1. getByteCount(需要在运行时动态计算出来)
            2. 宽 * 高 * 一像素占用内存。——直接计算结果
2. 常规方式

    图片对内存优化至关重要、图片宽高大于控件宽高（证明图片尺寸不合理）

    实现：继承ImageView，复写实现计算大小     总结：侵入性强，不通用
3. ART方式

    ARTHooK介绍：挂钩，将额外的代码挂住原有的方法，修改执行逻辑。应用场景：运行时插桩、性能分析

    Epic介绍：Epic是一个虚拟机层面、以java Method为粒度的运行时Hook框架，支持Android 4.0-10.0机型。Github地址：https://github.com/tiann/epic

        Epic使用方式：
            1. 添加依赖：implementation 'me.weishu:epic:0.6.0'
            2. 继承XC_MethodHook，实现相应的逻辑
            3. 注入Hook：DexposedBridge.findAndHookMethod
        Epic使用示例详见：com.android.performanceanalysis.hook包下ImageHook的使用
    优点：无侵入性，通用性强，兼容问题大，开源方案不能带到线上环境
## 五、线上内存监控方案
1. 常规实现一：设定场景线上Dump：Debug.dumpHprofData(“fileName”); 比如：超过最大内存的80% -> 内存dump -> 回传文件(文件比较大) -> MAT手动分析

    总结：Dump文件太大，和对象数正相关，可裁剪。上传失败率高，分析困难。配合一定的策略，有一些效果。
2. 常规实现二：LeakCanary带到线上，预设泄漏怀疑点，发现泄漏回传

        LeakCanary原理：
        监控生命周期，onDestroy添加RefWatcher检测，RefWatcher检测会进行二次确认断定发生内存泄漏，继而分析泄漏，找引用链
        LeakCanary架构：监控组件+分析组件

        LeakCanary定制：
            预设怀疑点->自动找怀疑点（谁占用内存大）
            分析泄漏链路慢->只分析Retain size大的对象
            分析OOM(内存堆栈生成所有文件全部映射到内存中，占用内存)->对象裁剪，不全部加载到内存

    总结：不适合所有场景，必须预设怀疑点。分析比较耗时，也容易OOM。
3. 线上内存监控完整方案

        监测常规指标：待机内存、重点模块内存、OOM率
        其次需要监控：整体及重点模块GC次数、GC时间
        最后将LeakCanary带到线上(帮助我们做自动化的内存泄漏分析)：需要定制增强LeakCanary自动化内存泄漏分析
## 六、内存优化技巧总结
1. 优化大方向：内存泄漏、内存抖动、Bitmap
2. 优化细节

        LargeHeap属性(提升分配内存的上限，但是更容易提升被杀的概率，然而大家都开)
        onTrimMemory(低内存状态，在最严重的状态下情况图片和界面跳转到主界面，影响用户体验但是比被系统干掉要好)
        使用优化过的集合：SparseArray
        谨慎的使用Sharepreference(第一次加载将所有数据load到内存中)
        谨慎使用外部库(使用的要是经过验证的，比较成熟的库)
        业务架构设计合理(如：城市数据结构，一次加载很多，可以分级为省市县等)


