## 1. 源文件规范
### [强制] 1.1 文件编码格式：所有源文件编码必须是UTF-8
### [强制] 1.2 文件命名：
1. 如一个源码文件仅包含一个顶级类，
2. 则必须和它包含的顶层类名保持一致，包括大小写
3. 如包含多个顶级定义，请选择一个能够描述该文件内容的名字作为文件名，并符合帕斯卡命名法(首字母大写)
### [强制] 1.3 特殊字符
1. 除了换行符之外，ASCII空格（0x20）是唯一合法的空格字符。这意味着：所有在源代码中（包括字符、字符串以及注释中）出现的其他空格字符需要转义,例如Tab用\t表示。缩进必须使用空格而不是Tab,使用4个空格来标示Tab缩进
2. 特殊转义字符：对于有特殊转义表示的字符(\b, \n, \r, \t, \', \", \\, and \$),，禁止使用其它等价Unicode转义方式。例如\u000a表示。
3. 对于其他的非ASCII字符,如何选择的依据是可读性,比如: (∞) 等价的unicode是 (\u221e)

## 2. 源文件组织结构
[强制] 源文件必须按顺序由以下部分组成：
* 许可证（License）或版权声明（Copyright） （可选）
* 文件级的注解：根据相应的类型来合理使用注解，但必须在版权/许可证之后，package声明语句之前。例如：@file:JvmName("Foo")
* [强制] package语句：package语句占据单独一行不换行，允许超出120字符列宽限制。
* [强制] import语句：
  * 非static imports，禁止使用通配符import。
  * 每条import语句占据单独一行不换行，允许超出120字符列宽限制。
  * 所有未使用的import语句应该被删除。
* [强制] 顶层声明：
  * 一个.kt 的文件中可以定义一个或多个顶级类型、方法、属性、类别名。
  * 一个源文件中的内容必须是一个主题(模块)。
  * 每个类中的声明，都应该以业务逻辑顺序排列，想相关联的放到一起，不应该按照字母顺序、时间顺序、可见性来区分或者常规方法扩展方法区分

每两部分之间用一个空行分隔，不允许多个空行。

[强制] 类成员的顺序(同 顶级声明 的顺序)：
1. 属性声明与初始化块
2. 次构造函数
3. 方法声明
4. 伴生对象

目录结构：在混合语言项目中，Kotlin 源文件应当与 Java 源文件位于同一源文件根目录下，并遵循相同的目录结构（每个文件应存储在与其 package 语句对应的目录中 ）。在纯 Kotlin 项目中，推荐的目录结构遵循省略了公共根包的包结构。

## 3. 代码格式
### 3.1. 花括号
1. [强制] 基本使用：if 语句如果用于赋值语句或者表达式等适合单行的场景，不用写括号 ； when语句中，如果分支仅有一行，不用写括号。if如果没有 else\else if 分支，要换行
2. [强制] 除1中情况,任何使用if、when、for、do、while语句时，对于其有效作用域，都必须使用花括号，即使其中只有一行代码
3. [强制] 非空代码块：在非空代码块中使用花括号时要遵循K&R风格（Kernighan and Ritchie Style）：
   * 左花括号（{）前不能换行，在其后换行。
   * 在右花括号（}）前要有换行。
   * 右大括号后还有 else 等代码则不换行 表示终止的右大括号后必须换行。
4. [强制] 空代码块：与java不同,空代码块、构造函数也必须遵循非空代码块的K&R风格
### 3.2 [强制] 块缩进：4个空格
每次开始书写一个新的代码块时，使用4个空格进行缩进，在代码块结束时，恢复之前的缩进级别,该级别适用于整个块中的代码和注释
### 3.3 [强制] 每行只写一条语句：每条语句之后都要换行,结尾没有分号
### 3.4代码换行：
[强制] 单行字符数限制不超过120个，超出需要换行或进行缩减
1. 例外情况：
   * 120字符无法满足的情况，如：注释中一个很长的URL
   * package及import语句
   * 注释中可能复制粘贴到shell脚本中的内容
2. [强制] 换行规则:换行规则的主旨--在更高阶的语法处进行折行，最终目的是为了保证代码可读性。
   * 第二行相对第一行缩进4个空格，从第三行开始，与第二行对齐。
   * 非赋值运算符,包括 (.) 和 (::),在运算符前换行。
   * 赋值运算符,在运算符后进行换行。
   * 方法或构造函数后的左括号(()，应保持在同一行。
   *  (,)（逗号）与其之前的内容保持在一行。
   * Lambda箭头运算符 (->) 与其之前的参数列表保持在一行。
3. [强制] 方法换行：当一个方法无法写在一行时，请按参数定义进行换行
   * 每行定义一个参数，同时使用比方法多4个字符的空格进行缩进
   * 右括号  ())  和返回类型的定义单独放在一行内，这一行不需要缩进(即和方法开头 对齐)
     ```
     fun <T> Iterable<T>.joinToString(
         separator: CharSequence = ", ",
         prefix: CharSequence = "",
         postfix: CharSequence = ""
     ): String {
         // …
     }
     ```
4. [强制] 表达式方法换行：当一个方法仅包含一行代码时，可以将其写为表达式方法
   * 表达式方法不应折行，如果需要折行，请改为普通的方法，使用return进行返回
   * 当表达式函数使用代码块时使用多行
     ```
     // normal functions
     override fun toString(): String {
         return "Hey"
     }
      
     // Expression functions
     override fun toString(): String = "Hey"
     
     fun main() = runBlocking {
       // …
     }
     ```
5. [强制] 属性：如果属性的定义超过120字符,在(=) 之后进行换行,并使用连续缩进的方式进行缩进
   * 重写get/set方法时，应当将其放在单独一行，并附加4个字符的缩进，使用普通方法的格式规则
   * 只读属性，可以使用减短的语法重写get方法，并保持在一行( val defaultExtension: String get() = "kotlin" )
### 3.5 空白
1. [强制] 空行：在每个函数第一条语句前，类的第一个成员前，类的最后一个成员后添加空行。(不推荐使用连续超过3个的空行。)
   * 在类的不同的成员间增加空行，包括：成员变量、构造函数、方法、内部类、静态初始化块、实例初始化块等
   * 两个成员变量声明之间可以不加空行。空行通常用于对成员变量进行逻辑分组。
   * 方法体内，按需增加空行，以便从逻辑上对语句进行分组
   * 第一个类成员前建议添加一个空白换行
   * [可选] 每个函数第一条语句前，类的第一个成员前，类的最后一个成员后添加空行。
   * 不推荐使用连续超过3个的空行。
2. [强制] 空格：用好格式化代码快捷键即可
   * 除了语法要求，字符串内的空格，以及JavaDoc里的空格，需要在下列情况里使用空格：if/for/while/switch/do/else/catch 等保留字与括号之间都必须加空格。
   * 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格；
   * 方法参数在定义和传入时，多个参数逗号后边必须加空格。
   * 在任意左花括号（{）之前要有一个空格。@SomeAnnotation({a, b})和String[][] x = {{"foo"}};这两种情况除外。
   * 在双目两边各要有一个空格。该规则同样适用于<T extends Foo & Bar>中的（&），catch (FooException | BarException e)中的|，以及foreach中的（:），以及Lambda运算符（->）
   * 例外情况（不应在其左右添加空格）:
      * 使用双冒号运算符（::）引用类成员时
      * 点运算符（.）
      * 范围运算符（..）
   * 当且仅当在类定义（继承、实现）及泛型中使用where约束的冒号前（:）应当添加一个空格
   * 在用于行末注释的//前后各要有一个空格
   * 在声明语句的类型和名称之间要有一个空格，比如List<String> list
   * 在逗号（,）、冒号（:）,后要有一个空格
   * 除行首缩进、注释和字符串内的空格以外，禁止使用连续的空格
### 3.6. 特定结构
1. 枚举类
   * [强制] 无函数及常量无注释文档的枚举类，可以定义在一行
   * [强制] 当常量定义在多行时，常量之前不要添加空行，除非包含body的定义
   * 枚举类也是类,其他的规则和普通类一样
2. 注解
   * [强制] 含有参数的注解，各占一行
   * [推荐] 如果多个注解,且注解不含参数,可以写到同一行中
   * [推荐] 如仅有一个无参数的注解，可以将其与其修饰内容的定义放在一行
3. [推荐] 隐式 返回/属性 类型：如果函数的返回值、属性初始化的值可以直观的判断出其类型时，类型声明可以省略，其他情况不可省略类型定义
4. 当编写类库、sdk 时，public接口建议保留显式的类型声明，以便使用者阅读
### 3.7 其他说明：如果一个声明有多个修饰符，请始终按照以下顺序安放：[强制]
```
public / protected / private / internal
expect / actual
final / open / abstract / sealed / const
external
override
lateinit
tailrec
vararg
suspend
inner
enum / annotation
companion
inline
infix
operator
data
```

## 4. 命名
### 4.1 通用命名规范
所有的标识符只允许使用ASCII字符和数字，标识符命名必须能够匹配正则表达式：\w ([0-9a-zA-Z_])。
禁止使用一些特定的前缀和后缀，比如：name_、mName、m_name。
不建议使用中文拼音来命名。
### 4.2 包名
[强制] 包名必须使用小写字母，连续单词直接拼接即可，不允许使用下划线。
### 4.3 类和接口命名
1. [强制] 类名（包括接口名）的命名使用名词或名词短语(如:List),但有时候也可以用形容词(如:Runnable)
2. [强制] 测试类以Test作为后缀名 (如:HashTest or HashIntegrationTest)
3. [强制] 类名（包括接口名）必须使用帕斯卡式命名（PascalCase）,并使用名词或名词短语
### 4.4 方法名
1. 方法名必须使用驼峰式命名，通常为动词或动词短语（如：stop、sendMessage)
2. 利用下划线命名来区分测试方法,其他情况下禁止使用下划线
### 4.5 常量名
[强制] 常量（标有 const 的属性，或者保存不可变数据的没有自定义 get 函数的顶层/对象 val 属性）,应该使用大写、下划线分隔的名称
[强制] 常量只能定义在top-level 或着 object 中,其他满足常量定义但是存放在class中的,必须以非常量命名;
此外,不建议 在object或companion object中定义常量，避免开辟不必要的内存空间
### 4.6 非常量名
[强制] 非常量(包括实例属性(instance properties)、本地属性(local properties)和参数名)以驼峰式命名，通常为名词及名词短语
### 4.7 幕后属性(backing properties)
[强制] 如果一个类有两个概念上相同的属性，一个是公共 API 的一部分，另一个是实现细节，那么使用下划线作为私有属性名称的前缀
### 4.8 类型变量名(泛型)
1. [强制] 类型变量名的命名可以有2中风格:
   * 单独的一个大写字母,后面可添加数字 (如: E, T, X, T2)
   * 一种类的命名形式，并附加一个大写字母T (如: RequestT, FooBarT)
### 4.9 驼峰命名方式定义
1. 通常有多种方式将短语组织成驼峰方式，像一些缩写词：IPv6、iOS等。为了统一，必须遵循以下几点规则。
   * 将字符全部转换为ASCII字符，并且去掉’等符号。例如，Müller's algorithm被转换为Muellers algorithm
   * 在空格和标点符号处对上一步的结果进行切分，组成一个词组。
   * 经过上面两步后，先将所有的字母转换为小写，再把每个词语的第一个字母转换为大写。
   * 最后，将所有词语连在一起，形成一个标识符。
2. 推荐：一些已经是驼峰命名的词语，也应该在这个时候被拆分。（例如 AdWords 被拆分为 ad words）。但是例如iOS之类的词语，它其实不是一个驼峰形式的词语，而是人们惯例使用的一个词语，因此不用做拆分。
3. 注意：有些词语在英文中，可以用[-]连接使用，也可以不使用[-]直接使用。例如“nonempty”和“non-empty”都可以。因此方法名字为checkNonempty或者checkNonEmpty都是合法的写法。

## 5. 文档注释
### 5.1. 注释格式
* [强制] public方法、变量、常量（即对外部暴露的内容）必须用doc的形式编写注释，私有内容尽量也添加注释，方法建议对参数、返回值进行说明，以便使用者参考，尽快理解含义
* [建议] 可以使用一些特殊标记进行说明。特殊标记必须使用单行注释的形式。下面列举了一些常用标记：
   * TODO: 有功能待实现。此时需要对将要实现的功能进行简单说明。
   * FIXME: 该处代码运行没问题，但可能由于时间赶或者其他原因，需要修正。此时需要对如何修正进行简单说明。
   * HACK: 为修正某些问题而写的不太好或者使用了某些诡异手段的代码。此时需要对思路或诡异手段进行描述。
   * XXX: 该处存在陷阱。此时需要对陷阱进行描述。
### 5.2. 段落
每段注释，使用一个带有*的前缀空行分隔
### 5.3. 注释中的标签
[强制] 可使用如下标签对相关内容进行标注：@constructor、@receiver、@param、@property、@return、@throws、@see，同时必须包含描述;当标签无法放在一行时，其第二行从（@）位置起偏移4个空格

## 6. 编程实践
### 6.1. 空安全
1. [强制] 非空属性的赋值：大部分情况下,禁止使用 !!(除非在100%确定内容不会为空,如:TextUtils.isEmpty()、string.isNullOrEmpty之后) ,推荐使用 let 或者 ?
2. [强制] 可空类型作为参数
   * 如果继承自java的方法,如果方法的参数没有明确的 不可空 注解,函数参数必须为可空类型
   * 如果方法会存在与java互相调用的情况,参数必须为可空类型,防止运行时出现空导致崩溃
3. [建议] 类型转换：建议所有进行类型转换的操作，都使用as?，以防止类型不匹配导致的异常问题
4. [建议] 懒加载的使用：
   * 尽量不要使用lateinit来定义不可空类型的变量，可能会在使用时出现null的情况
   * 只读变量（val修饰）可以使用by lazy { }实现懒加载，可变变量（var修饰）使用改写get方法的形式实现懒加载
5. 获取布局中的控件(View)：尽量不要直接使用View的 id 代替 findViewById()，如果需要使用，需要在id后面加问号（？）。主动findViewById更佳
### 6.2. 性能
1. [建议] 基础数据类型的可空性选择：基础数据类型避免自动装箱成为包装类，尽量使用不可空类型
2. [建议] 集合遍历使用垂直计算：如果对集合或数组多次遍历操作时，使用asSequence() 提高性能
3. [建议] 纯工具静态方法的使用：直接写到.kt文件里，顶层函数的形式。在类里的companion object中或者object对象中定义，会有额外开销，如不得不在伴生对象中实现静态方法，请添加@JvmStatic注解。
4. [强制] 成员变量的可见性：外部没有调用的成员变量，必须设置成private，减少不必要的包体积增长。
5. [建议] inline、noinline 和 crossinline。参考：https://juejin.im/post/6869954460634841101
   * inline：可以让你用内联——也就是函数内容直插到调用处——的方式来优化代码结构，从而减少函数类型的对象的创建；
      * inline 关键字的用处：高阶函数（Higher-order Functions）有它们天然的性能缺陷，我们通过 inline 关键字让函数用内联的方式进行编译，来减少参数对象的创建，从而避免出现性能问题。
      * inline 是用来优化的吗？是，但你不能无脑使用它，你需要确定它可以带来优化再去用它，否则可能会变成负优化。其实换个角度想想：既然 inline 是优化，为什么 Kotlin 没有直接开启它，而要把它做成选项，而且还是个默认关闭的选项？就是因为它还真不一定是优化，加不加它需要我们自己去做判断。那怎么去做这个判断呢？很简单，如果你写的是高阶函数，会有函数类型的参数，加上 inline 就对了。
   * noinline：是局部关掉这个优化，来摆脱 inline 带来的「不能把函数类型的参数当对象使用」的限制；
      * noinline 的作用是什么？是用来局部地、指向性地关掉函数的内联优化的。既然是优化，为什么要关掉？因为这种优化会导致函数中的函数类型的参数无法被当做对象使用，也就是说，这种优化会对 Kotlin 的功能做出一定程度的收窄。而当你需要这个功能的时候，就要手动关闭优化了。这也是 inline 默认是关闭、需要手动开启的另一个原因：它会收窄 Kotlin 的功能。
      * 那么，我们应该怎么判断什么时候用 noinline 呢？很简单，比 inline 还要简单：你不用判断，Android Studio 会告诉你的。当你在内联函数里对函数类型的参数使用了风骚操作，Android Studio 拒绝编译的时候，你再加上 noinline 就可以了。
   * crossinline：是局部加强这个优化，让内联函数里的函数类型的参数可以被当做对象使用。什么时候需要 crossinline？当你需要突破内联函数的「不能间接调用参数」的限制的时候。但其实和 noinline 一样，你并不需要亲自去判断，只要在看到 Android Studio 给你报错的时候把它加上就行了。
### 6.3. 异常
[建议] try-catch：对于Java中要求强制加try-catch的场景，编译器不会自动提示，需要我们自己加上，如：new JSONObject("xxx")，xx.toInt()等。catch住的Exception应当正确处理，如throw给上层调用，或printStackTrace，不应直接忽略。I/O操作及加锁操作或可能出现内存泄露的场景，必须使用finally语句进行处理
### [建议] 6.4. 语言特性习惯用法
1. 不变性：优先选择使用不变数据。初始化后就不再改变的局部变量和属性，使用val代替var声明。函数参数，返回值是集合的，优先考虑使用不变集合（Collection, List, Set, Map）。
2. 默认值：优先选择使用函数默认值代替重载函数。
3. 类型别名：反复使用的函数类型或参数类型，建议使用类型别名。 typealias MouseClickHandler = (Any, MouseEvent) -> Unit
4. lambda拉姆达参数：多层lambda嵌套时，为了提高代码可读性参数不能使用it，需要显示声明。
5. 命名参数：函数有多个相同原始类型或者多个布尔型的参数时，使用命名参数提升可读性。
6. 条件语句：使用try,if,when的表达式代替语句。即此些表达式都带返回值，均可直接return
7. 区间循环：开区间上循环时，使用until
8. 字符串模板：使用字符串模板代替字符串拼接。不需要缩进时用trimIndent()，保留缩进用trimMargin()

## 7. Contribute协程
1. 协程了解(视频+文档)
   * Kotlin 的协程用力瞥一眼：https://juejin.im/post/6844903949686800392
   * Kotlin 协程的挂起好神奇好难懂？今天我把它的皮给扒了：https://juejin.im/post/6844903968699580430
   * 到底什么是「非阻塞式」挂起？协程真的更轻量级吗？：到底什么是「非阻塞式」挂起？协程真的更轻量级吗？
2. Kotlin 协程实现原理：https://blog.csdn.net/suyimin2010/article/details/91125803
