## 算法学习链接
<a href="https://blog.csdn.net/m0_37907797/article/details/102661778">程序员必须掌握的核心算法有哪些？</a>

<a href="https://blog.csdn.net/u013850277/article/details/90647636">程序员小灰2017-2019年原创汇总</a>

<a href="https://blog.csdn.net/qq_35524157/article/details/103136863">二叉树之建树和七种遍历(含Java代码)</a>



## 算法心得
### 树
* 前提：树基本使用链表或者数组实现。
    * 链表Node类中分别有left(Node)和right(Node)以及当前节点值；
    * 数组Array中0下标为根节点，而其n节点的左子树为2*n+1下标，其n节点的右子树为2n*2下标，最后一个非叶子节点是(length - 2) / 2位置。
* 二叉树：二叉树是每个结点最多有两个子树的树结构。
* 二叉查找树(二叉排序树、二叉搜索树)：左子树小于父节点，右子树大于父节点的树。
它支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，理想情况下，时间复杂度是 O(logn)。
不过，二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于 log2n 的情况，从而导致各个操作的效率下降。极端情况下，二叉树会退化为链表，时间复杂度会退化到 O(n)。
    * 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
    * 若右子树不空，则右子树上所有结点的值均大于它的根结点的值；
    * 左、右子树也分别为二叉排序树；
    * 没有键值相等的结点。
* 平衡二叉树(AVL)：二叉树中任意一个节点的左右子树的高度相差不能大于 1。满二叉树、完全二叉树都是平衡二叉树。解决普通二叉查找树在进行数据插入、删除等动态更新操作时出现时间复杂度退化问题。
* 红黑树：平衡树是为了解决二叉查找树退化为链表的情况，而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。
    * 性质1：每个节点要么是黑色，要么是红色。
    * 性质2：根节点是黑色。
    * 性质3：每个叶子节点（NIL）是黑色。
    * 性质4：每个红色结点的两个子结点一定都是黑色。
    * 性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。
    * https://www.jianshu.com/p/e136ec79235c
* 哈夫曼树
* 堆(大堆和小堆)：堆通常是一个可以被看做一棵完全二叉树的数组对象。最大堆：父节点总比左右子节点大或等于，根节点最大。最小堆：父节点总比左右子节点小或等于，根节点最小。
    * 堆中某个节点的值总是不大于或不小于其父节点的值；
    * 堆总是一棵完全二叉树。
    * 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。
    * 堆的意义就在于：最快的找到最大/最小值，在堆结构中插入一个值重新构造堆结构，取走最大/最下值后重新构造堆结构 其时间复杂度为O(logN)，而其他方法最少为O(N).堆实践中用途不在于排序，其主要用在调度算法中，比如优先级调度，每次取优先级最高的，时间驱动，取时间最小/等待最长的 等等 ，分为最大堆/最小堆。
