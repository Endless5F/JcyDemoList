### OkHttp
1. 简述一下OkHttp
    ```
    OkHttp 是一个高效的 HTTP 客户端:
    支持 HTTP/2 ，共享同一个Socket来处理同一个服务器的所有请求
    如果 HTTP/2 不可用，则通过连接池来减少请求延时
    无缝的支持 GZIP 来减少数据流量
    缓存响应数据来减少重复的网络请求

    OkHttp 会从很多常用的连接问题中自动恢复。如果你的服务器配置了多个 IP 地址，当第一个 IP 连接失败的时候，OkHttp 会自动尝试下一个 IP。OkHttp 还处理了代理服务器问题和 SSL 握手失败问题。
    使用 OkHttp 无需重写程序中的网络代码。OkHttp 实现了几乎和 HttpURLConnection 一样的 API 。如果使用了 Apache HttpClient，OkHttp 也提供了一个对应的 okhttp-apache 模块。
    OkHttp 支持 Android 2.3 以上版本，java 最低要求 1.7 版本
    ```
2. OkHttp总体设计
    ```
    第一，通过一个构建者模式（Request.Builder）构建所有的request，然后分发到Dispatcher(分发器)；
    第二，Dispatcher再根据request请求是同步还是异步分别入队不同的队列中，若是同步则直接执行，若是异步则入队到准备队列中等待执行，接着通过拦截器(至少5个)链获得响应；
    第三，5个OkHttp自带的拦截器链：RetryAndFollowUpInterceptor(重试并跟踪拦截器，重连机制)、BridgeInterceptor(桥连接拦截器，封装请求头、响应体解析)、CacheInterceptor(缓存连接器，缓存数据、可防止频繁访问)、ConnectInterceptor(连接拦截器，连接复用机制)、CallServerInterceptor(呼叫服务器拦截器，请求数据)
    ```
3. OkHttp的多路复用机制(连接池)
    ```
    OkHttp通过ConnectionPool维护连接池，ConnectionPool通过队列Deque<RealConnection>持有当前所有的连接；
    新创建的连接通过put方法加入到队列，加入队列前先执行一遍清理；get方法会根据传入的Address和Route遍历连接队列，返回可以复用的连接，复用的条件既要满足分配流的上限原则，也需protocol、ssl、host等配置匹配；
    ConnectionPool通过一个专门的线程清理失效的连接，该线程每执行完一次清理都会根据返回的等待时间阻塞等待；清理的逻辑即遍历每个连接，通过连接对StreamAlloction的弱引用计数器来判断是否空闲（计数为0则说明空闲），通过遍历队列，找出空闲时长最长的连接，再根据已到保活的时长（keepalive）或空闲连接数的上限进行清理回收。
    ```
4. 重连机制
    ```
    每一个call(RealConnection)在connect连接过程中抛出RouteException路线异常，则在RetryAndFollowUpInterceptor重试并跟踪拦截器中，就会调用recover()开始重定向或者失败重连，这是一个while死循环，只有获取到数据后获取超过最大阀值20次后，才会break跳出死循环。
    ```
5. 我们的网络请求非常多时，多达Integer.MAX_VALUE，这个线程池性能消耗是否特别大？
    ```
    不会的，因为OkHttp中的runningAsyncCalls队列最大为64，因此也限制了OkHttp的请求不会超过64，也就是就算我们设置了Integer.MAX_VALUE，对我们的性能也不会有影响。
    ```
## Retrofit