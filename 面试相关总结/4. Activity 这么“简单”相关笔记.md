17. Activity的启动流程是怎样的？
    ```
    面试官视角：这道题想考察什么？
        1. 是否熟悉Activity启动过程中与AMS的交互过程(高级)
        2. 是否熟悉 Binder 通信机制(高级)
        3. 是否了解插件化框架如何Hook Activity启动(高级)
        4. 阐述 Activity 转场动画的实现原理可加分(中级)
        5. 阐述 Activity 的窗口显示流程可加分(高级)
    题目剖析：
        1. 与AMS交互
        2. Activity的参数和结果如何传递
        3. Activity如何实例化
        4. Activity生命周期如何流转
        5. Activity的窗口如何展示
        6. Activity转场动画的实现机制
    题目结论：
        Activity跨进程启动：
            请求进程A：startActivity——(AMP，ActivityManager代理对象)——>
            system_server进程：AMS(ActivityManagerService)
                解析Activity信息、处理启动参数
                启动目标进程——> Zygote --> 进程B --> 绑定新进程
                ATP(ApplicationThread在system_server进程的代理) --scheduleLaunchActivity/mH中EXECUTE_TRANSACTION消息执行任务(Android P)-->
            新进程B：ApplicationThread --> ActivityThread --> Activity生命周期
        Activity进程内启动：
            请求进程A：startActivity—(hook插入点1)—(AMP，ActivityManager代理对象)——>
            system_server进程：AMS(ActivityManagerService)
                解析Activity信息、处理启动参数、scheduleLaunchActivity/mH中EXECUTE_TRANSACTION消息处理(Android P)-->
            回到请求进程A：ApplicationThread --> ActivityThread -(hook插入点2)-> Activity生命周期
        Activity的参数传递：Activity之间切换交互，需要system_server进程作为中介，而两者之间的交流是通过Binder机制，而Binder机制依赖于Android内核中的Binder缓冲区，因此参数传递的大小依赖于Binder缓冲区的大小并且数据必须是可序列化的。
            传递大数据的方法：
                EventBus
                单例数据格式对象(注意内存泄露或者内存溢出的，考虑使用WeakReferences将数据包装起来)
                持久化 数据库、ACache(ASimpleCache)、文件之类的(缺点：数据量很大的时候读写时间慢，效率低下，IO容易出问题)
        Activity实例化：Activity实际上是在nstrumentation类的newActivity方法中被反射创建的。
        Fragment为什么不能添加有参数的构造方法？虽然Fragment可以通过new的方式创建，但是若涉及Activity状态的保存和恢复则可能会出问题。比如：Activity A可能由于长时间处于不可见而被杀死，则此时就涉及Activity状态的保存和恢复问题，而Activity中的FragmentManager会在Activity被销毁时，将所有Fragment按照android:fragments为key的数据里存储现在有哪些fragment显示、顺序、位置如何等等，当Activity需要恢复时则还是通过反射创建所以根本不知道需要构造参数如何赋值，因此无法给Activity或者Fragment添加有参数的构造方法，若fragment存在有参构造则最好有默认值处理。
        Activity窗口如何展示：
            newActivity
            activity-attach--> createPhoneWindow
            activity-create--> installDecor\addContentView\setContentView
            activity-start-->
            activity-restoreState
            activity-postCreate
            activity-resume--> 测量、布局、绘制
            activity-makeVisible--> 显示DecorView
        Activity转场动画的实现机制：

        注：Android P中创建新Activity由以前的scheduleLaunchActivity方法变成mH中EXECUTE_TRANSACTION消息执行ClientTransaction类型任务(实际为LaunchActivityItem类型)，继而执行client.handleLaunchActivity。
           client实际类型为ClientTransactionHandler，而在Android P中，ActivityThread extends ClientTransactionHandler，而ClientTransactionHandler封装了handlexxxActivity的方法。因此Android P中最后也是执行ActivityThread中的handleLaunchActivity方法执行创建Activity。
           EXECUTE_TRANSACTION消息由ActivityThread中sendActivityResult方法调用mAppThread.scheduleTransaction(clientTransaction)--> ActivityThread.this.scheduleTransaction(transaction) --> ClientTransactionHandler(隐藏抽象类，ActivityThread是其子类)中scheduleTransaction方法--> sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);
           简单列以下Android P的流程：
           1. startActivity--> Activity(startActivity-> startActivityForResult)--> Instrumentation(execStartActivity)--> ActivityManager(getService.startActivity)--> ActivityManagerService(startActivity)--> ActivityStartController(obtainStarter工厂方法模式)--> ActivityStarter(execute--> startActivityMayWait--> startActivity--> startActivityUnchecked)
           2. --> ActivityStackSupervisor(resumeTopActivityUncheckedLocked)--> ActivityStack(resumeTopActivityUncheckedLocked--> resumeTopActivityInnerLocked)--> ActivityStartSupervisor(startSpecificActivityLocked--> realStartActivityLocked)--> ClientLifecycleManager(scheduleTransation)--> ClientTransation(schedule)
           3. --> ActivityThread(ApplicationThread(scheduleTransation)--> scheduleTransation)--> ClientTransationHandler(scheduleTransation--> sendMessage(ActivityThread.H.EXECUTE_TRANSATION))--> ActivityThread(H(handleMessage))--> TransationExceutor(execute)--> LaunchActivityItem(excute)--> ClientTransationHandler(handleLaunchActivity)
           4(最后使用反射创建Activity). --> ActivityThread(handleLaunchActivity--> performLaunchActivity)--> Instrumentation(newActivity--> getFactory(pkg))--> ActivityThread(peekPackageInfo)--> LoadedApk(getAppFactory)--> AppComponentFactory(instantiateActivity(cl, className, intent)--> (Activity) cl.loadClass(className).newInstance())--> Activity(performCreate--> onCreate)
        小技巧：若在代码中无法找到隐藏类，则可在文件顶部，先查找此类包名，再想办法进行查找。
    ```
