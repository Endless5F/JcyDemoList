17. Activity的启动流程是怎样的？
    ```
    面试官视角：这道题想考察什么？
        1. 是否熟悉Activity启动过程中与AMS的交互过程(高级)
        2. 是否熟悉 Binder 通信机制(高级)
        3. 是否了解插件化框架如何Hook Activity启动(高级)
        4. 阐述 Activity 转场动画的实现原理可加分(中级)
        5. 阐述 Activity 的窗口显示流程可加分(高级)
    题目剖析：
        1. 与AMS交互
        2. Activity的参数和结果如何传递
        3. Activity如何实例化
        4. Activity生命周期如何流转
        5. Activity的窗口如何展示
        6. Activity转场动画的实现机制
    题目结论：
        Activity跨进程启动：
            请求进程A：startActivity——(AMP，ActivityManager代理对象)——>
            system_server进程：AMS(ActivityManagerService)
                解析Activity信息、处理启动参数
                启动目标进程——> Zygote --> 进程B --> 绑定新进程
                ATP(ApplicationThread在system_server进程的代理) --scheduleLaunchActivity/mH中EXECUTE_TRANSACTION消息执行任务(Android P)-->
            新进程B：ApplicationThread --> ActivityThread --> Activity生命周期
        Activity进程内启动：
            请求进程A：startActivity—(hook插入点1)—(AMP，ActivityManager代理对象)——>
            system_server进程：AMS(ActivityManagerService)
                解析Activity信息、处理启动参数、scheduleLaunchActivity/mH中EXECUTE_TRANSACTION消息处理(Android P)-->
            回到请求进程A：ApplicationThread --> ActivityThread -(hook插入点2)-> Activity生命周期
        Activity的参数传递：Activity之间切换交互，需要system_server进程作为中介，而两者之间的交流是通过Binder机制，而Binder机制依赖于Android内核中的Binder缓冲区，因此参数传递的大小依赖于Binder缓冲区的大小并且数据必须是可序列化的。
            传递大数据的方法：
                EventBus
                单例数据格式对象(注意内存泄露或者内存溢出的，考虑使用WeakReferences将数据包装起来)
                持久化 数据库、ACache(ASimpleCache)、文件之类的(缺点：数据量很大的时候读写时间慢，效率低下，IO容易出问题)
        Activity实例化：Activity实际上是在nstrumentation类的newActivity方法中被反射创建的。
        Fragment为什么不能添加有参数的构造方法？虽然Fragment可以通过new的方式创建，但是若涉及Activity状态的保存和恢复则可能会出问题。比如：Activity A可能由于长时间处于不可见而被杀死，则此时就涉及Activity状态的保存和恢复问题，而Activity中的FragmentManager会在Activity被销毁时，将所有Fragment按照android:fragments为key的数据里存储现在有哪些fragment显示、顺序、位置如何等等，当Activity需要恢复时则还是通过反射创建所以根本不知道需要构造参数如何赋值，因此无法给Activity或者Fragment添加有参数的构造方法，若fragment存在有参构造则最好有默认值处理。
        Activity窗口如何展示：
            newActivity
            activity-attach--> createPhoneWindow
            activity-create--> installDecor\addContentView\setContentView
            activity-start-->
            activity-restoreState
            activity-postCreate
            activity-resume--> 测量、布局、绘制
            activity-makeVisible--> 显示DecorView
        Activity转场动画的实现机制：参考于https://www.jianshu.com/p/69d48f313dc4
            1. 内容过渡动画的原理
                1). Activity A 调用 startActivity()
                    系统遍历 A 的视图节点，找到将要运行退退出转换的所有过渡视图
                    A 的退出转换记录所有过渡视图的开始状态
                    系统将所有过渡视图的可见性设置为INVISIBLE
                    在下一帧，A 的退出转换记录所有过渡视图的结束状态
                    A 的退出转换比较每个过渡视图的开始状态和结束状态，然后创建 Animator 作为退出动画，运行该动画。
                2). Activity B 启动了
                    系统遍历 B 的视图节点，找到将要运行进入转换的所有过渡视图，设置这些过渡视图的可见性为INVISIBLE
                    B 的进入转换记录所有过渡视图的开始状态
                    系统将所有过渡视图的可见性设置为VISIBLE
                    在下一帧，B 的进入转换记录所有过渡视图的结束状态
                    B 的进入转换比较每个过渡视图的开始状态和结束状态，然后创建 Animator 作为进入动画，运行该动画。
                注：所有的内容转换都需要记录每个过渡视图的开始状态和结束状态。而抽象类Visibility已经做了这部分内容了，Visibility的子类只需要实现 onAppear() 和 onDisappear() 方法，创建过渡视图进入或退出场景的 Animator。Android 5.0 中Visibility有三个子类 -- Fade、Slide、Explode，如果有需要的话也可以自定义Visibility子类。
            2. 共享元素过渡动画的原理
               A 调用startActivity(intent, bundle)后，B 启动时，窗口的背景是透明的。
               系统以 A 为标准重新设置 B 的每个共享元素视图的大小和位置，过一会 B 的进入转换会记录 B 中所有共享元素的开始状态，而对于内容过渡来说，其他的 transitioning view 的可见性都是 INVISIBLE。
               系统再重新将 B 的每个共享元素视图的大小和位置设置为原来的样子，过一会 B 的进入转换会记录 B 中所有共享元素的结束状态。
               B 的进入转换比较每个共享元素的开始状态和结束状态，创建 Animator 作为共享元素动画。
               系统将隐藏 A 的所有共享元素视图，然后开始运行 B 的共享元素动画。在 B 的共享元素动画过程中，B 的窗口背景会逐渐变为不透明的。

               注：对比内容过渡动画，内容过渡动画中系统会修改 transition views 的可见性，而共享元素过渡动画中系统会修改 shared element views 的位置、大小和显示。而且我们也可以看出实际上共享元素的 view 其实并没有在 Activity/ Fragment 之间共享，事实上，我们看到的进入或者返回的共享元素过渡动画都是直接在 B 的视图中运行的。
        注：Android P中创建新Activity由以前的scheduleLaunchActivity方法变成mH中EXECUTE_TRANSACTION消息执行ClientTransaction类型任务(实际为LaunchActivityItem类型)，继而执行client.handleLaunchActivity。
           client实际类型为ClientTransactionHandler，而在Android P中，ActivityThread extends ClientTransactionHandler，而ClientTransactionHandler封装了handlexxxActivity的方法。因此Android P中最后也是执行ActivityThread中的handleLaunchActivity方法执行创建Activity。
           EXECUTE_TRANSACTION消息由ActivityThread中sendActivityResult方法调用mAppThread.scheduleTransaction(clientTransaction)--> ActivityThread.this.scheduleTransaction(transaction) --> ClientTransactionHandler(隐藏抽象类，ActivityThread是其子类)中scheduleTransaction方法--> sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);
           简单列以下Android P的流程：
           1. startActivity--> Activity(startActivity-> startActivityForResult)--> Instrumentation(execStartActivity)--> ActivityManager(getService.startActivity)--> ActivityManagerService(startActivity)--> ActivityStartController(obtainStarter工厂方法模式)--> ActivityStarter(execute--> startActivityMayWait--> startActivity--> startActivityUnchecked)
           2. --> ActivityStackSupervisor(resumeTopActivityUncheckedLocked)--> ActivityStack(resumeTopActivityUncheckedLocked--> resumeTopActivityInnerLocked)--> ActivityStartSupervisor(startSpecificActivityLocked--> realStartActivityLocked)--> ClientLifecycleManager(scheduleTransation)--> ClientTransation(schedule)
           3. --> ActivityThread(ApplicationThread(scheduleTransation)--> scheduleTransation)--> ClientTransationHandler(scheduleTransation--> sendMessage(ActivityThread.H.EXECUTE_TRANSATION))--> ActivityThread(H(handleMessage))--> TransationExceutor(execute)--> LaunchActivityItem(excute)--> ClientTransationHandler(handleLaunchActivity)
           4(最后使用反射创建Activity). --> ActivityThread(handleLaunchActivity--> performLaunchActivity)--> Instrumentation(newActivity--> getFactory(pkg))--> ActivityThread(peekPackageInfo)--> LoadedApk(getAppFactory)--> AppComponentFactory(instantiateActivity(cl, className, intent)--> (Activity) cl.loadClass(className).newInstance())--> Activity(performCreate--> onCreate)
        小技巧：若在代码中无法找到隐藏类，则可在文件顶部，先查找此类包名，再想办法进行查找。
    ```
