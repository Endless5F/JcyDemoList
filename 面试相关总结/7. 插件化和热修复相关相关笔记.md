29. 如何规避Android P对访问私有API的限制？
    ```
    概念引入：Github：tiann/FreeReflection
        《一种绕过Android P对非SDK接口限制的简单方法》 田维术 2018.6.7
        知乎链接：https://zhuanlan.zhihu.com/p/37819685
        Github链接：https://github.com/tiann/FreeReflection
    面试官视角：这道题想考察什么？
        1. 是否能够熟练使用Java反射(中级)
        2. 是否有Hook调用系统API的开发经验(高级)
        3. 是否对底层源码有扎实的语言功底和较强的分析能力(高级)
    题目剖析：
        1. 私有API包括哪些类型？
        2. 如何访问私有API？
        3. Android P如何做到对私有API访问的限制？
        4. 如何规避这些限制？
    题目结论：
        一星：
            私有API：
                1. 被系统隐藏的API，例如：
                    /**
                     * @hide
                     */
                    @SystemApi
                    public void convertFromTranslucent() {...}
                2. private方法
            访问私有API：
                1. 自行编译系统源码，并导入项目工程(对public hide方法有效)
                2. 使用反射
                    Method initMethod = AssetManager.class.getDeclaredMethod("init");
                    initMethod.setAccessible(true);
                  反射不仅可以绕过访问权限的控制，还可以修改 final变量
        二星：
            Android P的 API名单：
                白名单：SDK，所有APP均能访问
                浅灰名单：仍可以访问的非SDK函数/字段
                深灰名单：
                    对于目标SDK低于API级别28的应用，允许使用深灰名单接口
                    对于目标SDK为 API 28或更高级别的应用：行为与黑名单相同
                黑名单：受限，无论目标SDK如何，平台将表现为似乎接口并不存在。
                    使用此类成员，都会触发 NoSuchMethodError/NoSuchFieldException
                    获取此类成员对应的class 的方法和属性列表，亦不包含在内
            Android P对反射做了什么？
                Android P中若反射私有private方法，则Class#getDeclaredMethod(String name, Class<?>... parameterTypes)方法，
                对应一个native方法：
                    @FastNative
                    private native Method getDeclaredMethodInternal(String name, Class<?>[] args);
                此native方法JNI层对应：
                    static jobject Class_getDeclaredMethodInternal(JNIEnv *env, jobject javaThis, jstring name, jobjectArray args) {
                        .....
                        if(result == nullptr || ShouldBlockAccessToMember(result->GetArtMethod(), soa.Self())) {
                            return nullptr;
                        }
                        return soa.AddLocalReference<jobject>(result.Get());
                    }
                很明显这里的ShouldBlockAccessToMember(应该阻止成员访问)方法，就是用来判断是否阻止反射访问的：
                    static bool ShouldBlockAccessToMember(T *member, Thread *self) REQUIRES_SHARED(Locks::mutator_lock_) {
                        hiddenapi::Action action = hiddenapi::GetMemberAction(member, self, IsCallerTrusted, hiddenapi::kReflection);
                        ......
                        return action == hiddenapi::kDeny;
                    }
                而在ShouldBlockAccessToMember方法中又能发现若hiddenapi::GetMemberAction方法返回的action == hiddenapi::kDeny，就会block访问。
                接下来我们深入看一下hiddenapi::GetMemberAction方法：
                    template<typename T>
                    inline Action GetMemberAction(T* member, Thread* self, std::function<bool(Thread*)> fn_caller_is_trusted, AccessMethod access_method) REQUIRES_SHARED(Locks::mutator_lock_) {
                        DCHECK(member != nullptr);
                        // Decode hidden API access flags.
                        HiddenApiAccessFlags::ApiList api_list = member->GetHiddenApiAccessFlags();
                        // 第一个Hook点
                        Action action GetActionFromAccessFlags(member->GetHiddenApiAccessFlags());
                        if(action == kAllow) return action;
                        // Member is hidden. Invoke fn_caller_in_platform and find the origin of the access.
                        // 第二个Hook点
                        if(fn_caller_is_trusted(self)) return kAllow;
                        // Member is hidden and caller is not in the platform.
                        // 第三个Hook点
                        return detail::GetMemberActionImpl(member, api_list, action, access_method);
                    }
        三星：
            从上面hiddenapi::GetMemberAction方法中有三处Hook点可以绕过私有api访问限制：
                1. 第一处hook点：
                    Action action GetActionFromAccessFlags(member->GetHiddenApiAccessFlags());
                    if(action == kAllow) return action;
                   优化：修改Runtime 的 hidden_api_policy_
                2. 第二处hook点：
                    if(fn_caller_is_trusted(self)) return kAllow;
                   优化：将调用者的ClassLoader置空
                       -Java层直接反射将调用者Class的ClassLoader置为null
                       -Native层直接利用C++对象内存布局直接修改调用者Class的内存地址
                3. 第三个hook点：
                    return detail::GetMemberActionImpl(member, api_list, action, access_method);
                   优化：类似于第一处hook，修改Runtime 的 hidden_api_exemptions
            FreeReflection使用：
                1. 项目中添加依赖项(jcenter):
                    implementation 'me.weishu:free_reflection:2.2.0'
                2. Application.attachBaseContext添加一行 :
                    @Override
                    protected void attachBaseContext(Context base) {
                        super.attachBaseContext(base);
                        Reflection.unseal(base);
                    }
    ```
    一种绕过Android P上非SDK接口限制的简单方法：https://zhuanlan.zhihu.com/p/37819685
